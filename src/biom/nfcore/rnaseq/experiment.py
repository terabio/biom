import os
from pathlib import Path
from typing import Iterable

from attrs import define, field

from biom import bioproj
from biom.common import Stranded


@define(slots=True, frozen=True, eq=True, order=True, repr=True, hash=True, init=False)
class Experiment:
    descriptor: str = field()
    source: bioproj.Experiment = field()
    # Files generated by the pipeline
    bam: Path = field(converter=lambda x: Path(x))
    bigwig: Stranded[Path] = field(converter=lambda x: Stranded(*[Path(p) for p in x]))
    salmon: Path = field(converter=lambda x: Path(x))

    def __init__(self, descriptor: str, source: bioproj.Experiment, resfolder: os.PathLike[str]):
        # Folder with the results of the pipeline
        resfolder = Path(resfolder)
        if not resfolder.is_dir():
            raise ValueError(f"Results folder {resfolder} does not exist")

        # BAM file
        bam = resfolder / "star_salmon" / f"{descriptor}.markdup.sorted.bam"
        if not bam.exists():
            raise ValueError(f"BAM file {bam} does not exist")
        bai = bam.with_suffix(".bam.bai")
        if not bai.exists():
            raise ValueError(f"BAM index file {bai} does not exist")

        # Bigwig
        fwd = resfolder / "star_salmon" / f"{descriptor}.forward.bigWig"
        if not fwd.exists():
            raise ValueError(f"Forward bigWig file {fwd} does not exist")

        rev = resfolder / "star_salmon" / f"{descriptor}.reverse.bigWig"
        if not rev.exists():
            raise ValueError(f"Reverse bigWig file {rev} does not exist")

        bigwig = Stranded(fwd, rev)

        # Salmon file
        salmon = resfolder / "star_salmon" / descriptor / "quant.sf"
        if not salmon.exists():
            raise ValueError(f"Salmon file {salmon} does not exist")

        self.__attrs_init__(descriptor, source, bam, bigwig, salmon)

    @property
    def ind(self) -> str:
        return self.source.ind

    @property
    def library(self) -> bioproj.Library:
        return self.source.library

    @property
    def sample(self) -> bioproj.Sample:
        return self.source.sample

    @property
    def runs(self) -> Iterable[bioproj.SeqRun]:
        return self.source.runs
